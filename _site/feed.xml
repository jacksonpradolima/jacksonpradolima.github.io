<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.5.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2017-09-05T11:14:11-03:00</updated><id>http://localhost:4000/</id><title type="html">Jackson A. Prado Lima</title><subtitle>Computer Science PhD candidate.</subtitle><entry><title type="html">Publication - Automatic Generation of Search-Based Algorithms Applied to the Feature Testing of Software Product Lines</title><link href="http://localhost:4000/Publication-SBES-Automatic-Generation-of-Search-Based-Algorithms-Applied-to-the-Feature-Testing-of-Software-Product-Lines/" rel="alternate" type="text/html" title="Publication - Automatic Generation of Search-Based Algorithms Applied to the Feature Testing of Software Product Lines" /><published>2017-09-01T00:00:00-03:00</published><updated>2017-09-01T00:00:00-03:00</updated><id>http://localhost:4000/Publication-SBES-Automatic-Generation-of-Search-Based-Algorithms-Applied-to-the-Feature-Testing-of-Software-Product-Lines</id><content type="html" xml:base="http://localhost:4000/Publication-SBES-Automatic-Generation-of-Search-Based-Algorithms-Applied-to-the-Feature-Testing-of-Software-Product-Lines/">&lt;p&gt;The selection of products for the variability testing of Feature Models (FMs) is a complex task impacted by many factors. To solve this problem, Multi-Objective Evolutionary Algorithms (MOEAs) have been successfully used in the field known as Search-Based Software Engineering (SBSE). However, the design of a search-based approach is not an easy task for the software engineer, who can find some difficulties such as: the choice and configuration of the best MOEAs, the choice of the best search operators to be implemented, and so on. In addition to this, existing approaches are dependent on the problem domain and do not allow reuse. In this way the use of Hyper-Heuristic (HH) can help to obtain more generic and reusable search-based approaches, and because of this is considered a trend in the SBSE field. Following this trend and to contribute to reduce the software engineer’s efforts, this work explores the use of a hyper-heuristic for automatically generation of MOEAs to select test products from the FM, considering three factors: pairwise coverage, mutation score and cost, given by the number of products. The HH is based on a grammar that represents the elements, parameters and components of existing MOEAs and implements evolutionary operators, such as crossover and mutation, suitable for selection problems. In this way, it can be reused for other similar software engineering problems. Evaluation results show that the proposed approach obtains results that are better or statistically equivalent than similar approaches found in the literature.&lt;/p&gt;

&lt;p&gt;You will see more about this publication at soon.&lt;/p&gt;</content><author><name></name></author><summary type="html">The selection of products for the variability testing of Feature Models (FMs) is a complex task impacted by many factors. To solve this problem, Multi-Objective Evolutionary Algorithms (MOEAs) have been successfully used in the field known as Search-Based Software Engineering (SBSE). However, the design of a search-based approach is not an easy task for the software engineer, who can find some difficulties such as: the choice and configuration of the best MOEAs, the choice of the best search operators to be implemented, and so on. In addition to this, existing approaches are dependent on the problem domain and do not allow reuse. In this way the use of Hyper-Heuristic (HH) can help to obtain more generic and reusable search-based approaches, and because of this is considered a trend in the SBSE field. Following this trend and to contribute to reduce the software engineer’s efforts, this work explores the use of a hyper-heuristic for automatically generation of MOEAs to select test products from the FM, considering three factors: pairwise coverage, mutation score and cost, given by the number of products. The HH is based on a grammar that represents the elements, parameters and components of existing MOEAs and implements evolutionary operators, such as crossover and mutation, suitable for selection problems. In this way, it can be reused for other similar software engineering problems. Evaluation results show that the proposed approach obtains results that are better or statistically equivalent than similar approaches found in the literature.</summary></entry><entry><title type="html">Publication - A Multi-objective optimization approach for selection of second order mutant generation strategies</title><link href="http://localhost:4000/Publication-SAST-A-Multi-objective-optimization-approach-for-selection-of-second-order-mutant-generation-strategies/" rel="alternate" type="text/html" title="Publication - A Multi-objective optimization approach for selection of second order mutant generation strategies" /><published>2017-09-01T00:00:00-03:00</published><updated>2017-09-01T00:00:00-03:00</updated><id>http://localhost:4000/Publication-SAST-A%20Multi-objective%20optimization%20approach%20for%20selection%20of%20second%20order%20mutant%20generation%20strategies</id><content type="html" xml:base="http://localhost:4000/Publication-SAST-A-Multi-objective-optimization-approach-for-selection-of-second-order-mutant-generation-strategies/">&lt;p&gt;The use of Higher-Order Mutants (HOMs) presents some advantages concerning the traditional use of First-Order Mutants (FOMs). HOMs can better simulate real and subtle faults, reduce the number of generated mutants and test cases, and so on. However, the HOM space is potentially huge, and an efficient strategy to generate the best HOMs is fundamental. In the literature different strategies were proposed and evaluated, mainly to generate Second-Order Mutants (SOMs), but none has been proved to perform better in different situations. Due to this, the selection of the best strategy is an important task. Most times a lot of experiments need to be conducted. To help the tester in this task and to allow the use of HOMs in practice, this paper proposes a hyper-heuristic approach. Such approach is based on NSGA-II and uses the selection method Choice Function to automatically choose among different Low-Level Heuristics (LLHs), which, in this case, are search-operators related to existing SOM generation strategies. The performance of each LLH is related to some objectives such as the number of SOMs generated, the capacity to capture subtler faults and replace the constituent FOMs. In comparison with existing strategies, our approach obtained better results considering the used objectives, and statistically equivalent results considering mutation score with respect to the FOMs.&lt;/p&gt;

&lt;p&gt;You see more about this publication at &lt;a href=&quot;https://www.researchgate.net/publication/319439374_A_Multi-objective_optimization_approach_for_selection_of_second_order_mutant_generation_strategies&quot;&gt;here&lt;/a&gt; on ResearchGate.&lt;/p&gt;</content><author><name></name></author><summary type="html">The use of Higher-Order Mutants (HOMs) presents some advantages concerning the traditional use of First-Order Mutants (FOMs). HOMs can better simulate real and subtle faults, reduce the number of generated mutants and test cases, and so on. However, the HOM space is potentially huge, and an efficient strategy to generate the best HOMs is fundamental. In the literature different strategies were proposed and evaluated, mainly to generate Second-Order Mutants (SOMs), but none has been proved to perform better in different situations. Due to this, the selection of the best strategy is an important task. Most times a lot of experiments need to be conducted. To help the tester in this task and to allow the use of HOMs in practice, this paper proposes a hyper-heuristic approach. Such approach is based on NSGA-II and uses the selection method Choice Function to automatically choose among different Low-Level Heuristics (LLHs), which, in this case, are search-operators related to existing SOM generation strategies. The performance of each LLH is related to some objectives such as the number of SOMs generated, the capacity to capture subtler faults and replace the constituent FOMs. In comparison with existing strategies, our approach obtained better results considering the used objectives, and statistically equivalent results considering mutation score with respect to the FOMs.</summary></entry><entry><title type="html">Teaching - Battleship in C</title><link href="http://localhost:4000/Teaching-Battleship-C/" rel="alternate" type="text/html" title="Teaching - Battleship in C" /><published>2017-08-31T00:00:00-03:00</published><updated>2017-08-31T00:00:00-03:00</updated><id>http://localhost:4000/Teaching-Battleship-C</id><content type="html" xml:base="http://localhost:4000/Teaching-Battleship-C/">&lt;p&gt;Battleship in C with options in Portuguese &lt;img src=&quot;/images/brazil.png&quot; alt=&quot;_config.yml&quot; /&gt;&lt;/p&gt;

&lt;p&gt;A class work for the Federal University of Paraná students, class CI067 - Oficina de Computação (CI067 - Computer Workshop).&lt;/p&gt;

&lt;p&gt;To provide an example of solution using basic concepts (function, matrix, comments), I develop a project on GitHub with menu options and comments in portuguese.&lt;/p&gt;

&lt;p&gt;You can download the document about the project at &lt;a href=&quot;https://github.com/jacksonpradolima/battleship/raw/master/trabalho/Batalha%20Naval.pdf&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;You see more about this project at &lt;a href=&quot;https://github.com/jacksonpradolima/battleship&quot;&gt;here&lt;/a&gt; on GitHub.&lt;/p&gt;</content><author><name></name></author><summary type="html">Battleship in C with options in Portuguese</summary></entry><entry><title type="html">Project - C-Bio GrES - Beamer Presentation Template</title><link href="http://localhost:4000/Project-cbio-gres-beamer/" rel="alternate" type="text/html" title="Project - C-Bio GrES - Beamer Presentation Template" /><published>2017-08-21T00:00:00-03:00</published><updated>2017-08-21T00:00:00-03:00</updated><id>http://localhost:4000/Project-cbio-gres-beamer</id><content type="html" xml:base="http://localhost:4000/Project-cbio-gres-beamer/">&lt;p&gt;This project contains templates used by C-Bio and GrES Research Groups. The templates used are two: (i) a traditional LaTeX Beamer presentation template; and (ii) LaTeX Beamer presentation template derived from &lt;a href=&quot;https://github.com/FuzzyWuzzie/Beamer-Theme-Execushares&quot;&gt;Kenton Hamaluik’s Execushares template&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;You see more about this project at &lt;a href=&quot;https://github.com/jacksonpradolima/cbio-gres-beamer&quot;&gt;here&lt;/a&gt; on GitHub.&lt;/p&gt;</content><author><name></name></author><summary type="html">This project contains templates used by C-Bio and GrES Research Groups. The templates used are two: (i) a traditional LaTeX Beamer presentation template; and (ii) LaTeX Beamer presentation template derived from Kenton Hamaluik’s Execushares template.</summary></entry><entry><title type="html">Project - OficinaC - UFPR</title><link href="http://localhost:4000/Project-OficinaC/" rel="alternate" type="text/html" title="Project - OficinaC - UFPR" /><published>2017-08-11T00:00:00-03:00</published><updated>2017-08-11T00:00:00-03:00</updated><id>http://localhost:4000/Project-OficinaC</id><content type="html" xml:base="http://localhost:4000/Project-OficinaC/">&lt;p&gt;This text is in Portuguese &lt;img src=&quot;/images/brazil.png&quot; alt=&quot;_config.yml&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Repositório com resoluções dos exercícios apresentados na disciplina CI067 - Oficina de Computação do Departamento de Informática da Universidade Federal do Paraná. Professora da disciplina: Silvia Regina Vergilio.&lt;/p&gt;

&lt;p&gt;Você vê mais sobre essa disciplina &lt;a href=&quot;http://www.inf.ufpr.br/silvia/oficinac/oficinac.html&quot;&gt;aqui&lt;/a&gt; no site da professora Silvia.&lt;/p&gt;

&lt;p&gt;Você vê mais sobre o respositório &lt;a href=&quot;https://github.com/jacksonpradolima/oficinac&quot;&gt;aqui&lt;/a&gt; no GitHub.&lt;/p&gt;</content><author><name></name></author><summary type="html">This text is in Portuguese</summary></entry><entry><title type="html">Project - SimpsonsLBP</title><link href="http://localhost:4000/Project-SimpsonsLBP/" rel="alternate" type="text/html" title="Project - SimpsonsLBP" /><published>2017-08-10T00:00:00-03:00</published><updated>2017-08-10T00:00:00-03:00</updated><id>http://localhost:4000/Project-SimpsonsLBP</id><content type="html" xml:base="http://localhost:4000/Project-SimpsonsLBP/">&lt;p&gt;Local Binary Patterns with Python &amp;amp; OpenCV applied on Simpsons.&lt;/p&gt;

&lt;p&gt;You see more about this project at &lt;a href=&quot;https://github.com/jacksonpradolima/SimpsonsLBP&quot;&gt;here&lt;/a&gt; on GitHub.&lt;/p&gt;</content><author><name></name></author><summary type="html">Local Binary Patterns with Python &amp;amp; OpenCV applied on Simpsons.</summary></entry><entry><title type="html">Project - SUTs4MutationTesting</title><link href="http://localhost:4000/Project-SUTs4MutationTesting/" rel="alternate" type="text/html" title="Project - SUTs4MutationTesting" /><published>2017-08-04T00:00:00-03:00</published><updated>2017-08-04T00:00:00-03:00</updated><id>http://localhost:4000/Project-SUTs4MutationTesting</id><content type="html" xml:base="http://localhost:4000/Project-SUTs4MutationTesting/">&lt;p&gt;Systems Under Test for Mutation Testing in Java.&lt;/p&gt;

&lt;p&gt;You see more about this project at &lt;a href=&quot;https://github.com/jacksonpradolima/SUTs4MutationTesting&quot;&gt;here&lt;/a&gt; on GitHub.&lt;/p&gt;</content><author><name></name></author><summary type="html">Systems Under Test for Mutation Testing in Java.</summary></entry><entry><title type="html">Project - csv2bib</title><link href="http://localhost:4000/Project-csv2bib/" rel="alternate" type="text/html" title="Project - csv2bib" /><published>2017-06-08T00:00:00-03:00</published><updated>2017-06-08T00:00:00-03:00</updated><id>http://localhost:4000/Project-csv2bib</id><content type="html" xml:base="http://localhost:4000/Project-csv2bib/">&lt;p&gt;In some digital libraries, e. g. SpringerLink, the search results are available only in csv file, but the researchers need in other formats like bibtex. In this sense, this project was created to help the researchers converting csv file into bib file.&lt;/p&gt;

&lt;p&gt;You see more about this project at &lt;a href=&quot;https://github.com/jacksonpradolima/csv2bib&quot;&gt;here&lt;/a&gt; on GitHub.&lt;/p&gt;</content><author><name></name></author><summary type="html">In some digital libraries, e. g. SpringerLink, the search results are available only in csv file, but the researchers need in other formats like bibtex. In this sense, this project was created to help the researchers converting csv file into bib file.</summary></entry><entry><title type="html">Project - AirBnB New York Analysis</title><link href="http://localhost:4000/Project-AirBnB-Ny-Analysis/" rel="alternate" type="text/html" title="Project - AirBnB New York Analysis" /><published>2017-05-05T00:00:00-03:00</published><updated>2017-05-05T00:00:00-03:00</updated><id>http://localhost:4000/Project-AirBnB-Ny-Analysis</id><content type="html" xml:base="http://localhost:4000/Project-AirBnB-Ny-Analysis/">&lt;p&gt;Analysis of New York Airbnb data collected on April 2, 2017 using PySpark with Zeppelin.&lt;/p&gt;

&lt;p&gt;You see more about this project at &lt;a href=&quot;https://github.com/jacksonpradolima/airbnb-ny-analysis&quot;&gt;here&lt;/a&gt; on GitHub.&lt;/p&gt;</content><author><name></name></author><summary type="html">Analysis of New York Airbnb data collected on April 2, 2017 using PySpark with Zeppelin.</summary></entry><entry><title type="html">Publication - Hyper-Heuristic Based Product Selection for Software Product Line Testing</title><link href="http://localhost:4000/Publication-IEEECIM-Hyper-Heuristic-Based-Product-Selection-for-Software-Product-Line-Testing/" rel="alternate" type="text/html" title="Publication - Hyper-Heuristic Based Product Selection for Software Product Line Testing" /><published>2017-05-01T00:00:00-03:00</published><updated>2017-05-01T00:00:00-03:00</updated><id>http://localhost:4000/Publication-IEEECIM-Hyper-Heuristic%20Based%20Product%20Selection%20for%20Software%20Product%20Line%20Testing</id><content type="html" xml:base="http://localhost:4000/Publication-IEEECIM-Hyper-Heuristic-Based-Product-Selection-for-Software-Product-Line-Testing/">&lt;p&gt;A Software Product Line (SPL) is defined as a set of software systems that share a common and managed set of features satisfying specific needs of a particular market segment or domain [1]. The SPL offers a number of common artifacts for building products, including mandatory and variable elements. SPL approaches have been adopted by many software companies1 to ease reuse and reduce time and production costs. A feature represents a functionality that is visible to the user and can be designed as a variability, which represents a variable functionality that may or may not be present in a product. On the other hand, mandatory features are common to all SPL products. To facilitate feature management, most SPL methodologies use the Feature Model (FM) [2] to represent all the SPL variabilities and commonalities.&lt;/p&gt;

&lt;p&gt;You see more about this publication at &lt;a href=&quot;https://doi.org/10.1109/MCI.2017.2670461&quot;&gt;here&lt;/a&gt; on IEEE Xplore.&lt;/p&gt;</content><author><name></name></author><summary type="html">A Software Product Line (SPL) is defined as a set of software systems that share a common and managed set of features satisfying specific needs of a particular market segment or domain [1]. The SPL offers a number of common artifacts for building products, including mandatory and variable elements. SPL approaches have been adopted by many software companies1 to ease reuse and reduce time and production costs. A feature represents a functionality that is visible to the user and can be designed as a variability, which represents a variable functionality that may or may not be present in a product. On the other hand, mandatory features are common to all SPL products. To facilitate feature management, most SPL methodologies use the Feature Model (FM) [2] to represent all the SPL variabilities and commonalities.</summary></entry></feed>